ometa Condition {
    expr = atom:l operator:op atom:r -> [ op, l, r ],

    operator = ``<='' | '<' | ``>='' | '>' | ``=='' | ``!='',

    identifier = <(letter|'_') (letter | digit | '_')*>:v -> this._options.variables[v],

    floatnumber = (exponentfloat | pointfloat):f -> parseFloat(f),
    pointfloat  =  intpart?:x fraction:y -> x + "." + y
        | intpart:x '.' -> x + ".0",
    exponentfloat =  (pointfloat | intpart):f exponent:e -> f + 'e' + e,
    intpart       =  digit+:v -> v.join(''),
    fraction      =  '.' digit+:y -> y.join(''),
    exponent      =  ('e' | 'E') ('+' | '-')?:s digit+:e -> (s ? s : "") + e.join(''),

    longinteger = integer:i ('L' | 'l') -> i,
    integer = bininteger | octinteger | hexinteger | decimalinteger,
    decimalinteger = (nonzerodigit digit*):v -> parseInt(v, 10)
        | '0' -> 0,
    octinteger = /0o/i octdigit+:v -> parseInt(v.join(''), 8);
        | ('0' octdigit+):v -> parseInt(v, 8),
    hexinteger = /0x/i hexdigit+:v -> parseInt(v.join(''), 16),
    bininteger = /0b/i bindigit+:v -> parseInt(v.join(''), 2),
    nonzerodigit = /[1-9]/,
    octdigit = /[0-7]/,
    bindigit = /[01]/,
    hexdigit = digit | /[a-f]/i,

    stringliteral   =  stringprefix?:sp { this.stringMode = sp ? sp.toLowerCase() : '' } (longstring | shortstring),
    stringprefix    =  ``UR'' | ``Ur'' | ``uR'' | ``ur'' | ``br'' | ``Br'' | ``bR'' | ``BR''
                        | 'r' | 'R' | 'u' | 'U' | 'b' | 'B',
    shortstring     =  '\'' shortstringitem('\'')*:v '\'' -> v.join('')
                        | '"' shortstringitem('"')*:v '"' -> v.join(''),
    longstring      =  seq('\'\'\'') (~seq('\'\'\'') longstringitem)*:v seq('\'\'\'') -> v.join('')
                        | seq('"""') (~seq('"""') longstringitem)*:v seq('"""') -> v.join(''),
    shortstringitem :q = escapeseq | shortstringchar(q),
    shortstringchar :q =  ~('\\' | '\n' | seq(q)) char,
    longstringitem  =  escapeseq | longstringchar,
    longstringchar  =  ~'\\' char,
    escapeseq       =   ?( this.stringMode.match(/u/) ) seq('\\u') <digit digit? digit? digit?>:u -> String.fromCharCode(parseInt(u, 10));
                        | ?( !this.stringMode.match(/r/) ) seq('\\') <octdigit octdigit? octdigit?>:o -> String.fromCharCode(parseInt(o, 8));
                        | ?( !this.stringMode.match(/r/) ) seq('\\x') <hexdigit hexdigit>:x -> String.fromCharCode(parseInt(x, 16));
                        | ?( !this.stringMode.match(/r/) ) seq('\\') char:v -> unescape(v)
                        | ?( this.stringMode.match(/r/) ) seq('\\') char:v -> '\\' + v,

    atom = identifier | literal,

    literal = stringliteral | floatnumber | longinteger | integer
}

ometa Evaluator {
    interp = [ '>' anything:x anything:y ] -> x > y
        | ['<' anything:x anything:y ]     -> x < y
        | ['>=' anything:x anything:y ]    -> x >= y
        | ['<=' anything:x anything:y ]    -> x <= y
        | ['!=' anything:x anything:y ]    -> x != y
        | ['==' anything:x anything:y ]    -> x == y
}

function unescape(c) {
    switch (c) {
        case '\n': return '';
        case '\\': return '\\';
        case '"': return '"';
        case "'": return "'";
        case 'a': return '\u0007';
        case 'b': return '\u0008';
        case 'f': return '\u0012';
        case 'n': return '\n';
        case 'N': throw new Error("not supported");
        case 'r': return '\r';
        case 't': return '\t';
        case 'v': return '\u0011';
        default: return "\\" + c;
    }
}

module.exports = function (str, variables) {
    var tree = Condition.matchAll(str, 'expr', { variables: variables });
    return Evaluator.match(tree, 'interp');
}

module.exports.parser = Condition;
